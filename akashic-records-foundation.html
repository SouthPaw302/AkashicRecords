<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akashic Records — Nexus of Infinity</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background: 240 15% 8%;
            --foreground: 45 100% 95%;
            --card: 240 20% 12%;
            --card-foreground: 45 90% 92%;
            --glass: 240 30% 15%;
            --glass-border: 270 50% 35%;
            --popover: 240 25% 10%;
            --popover-foreground: 45 85% 90%;
            --primary: 45 85% 65%;
            --primary-foreground: 240 20% 12%;
            --primary-glow: 45 100% 75%;
            --secondary: 270 45% 25%;
            --secondary-foreground: 45 90% 92%;
            --secondary-glow: 270 60% 40%;
            --muted: 240 15% 18%;
            --muted-foreground: 240 10% 65%;
            --accent: 220 70% 50%;
            --accent-foreground: 45 100% 95%;
            --accent-glow: 220 80% 65%;
            --destructive: 0 75% 55%;
            --destructive-foreground: 45 100% 95%;
            --border: 240 20% 25%;
            --input: 240 25% 15%;
            --ring: 45 85% 65%;
            --radius: 1rem;
            --gradient-cosmic: linear-gradient(135deg, hsl(240 30% 15%), hsl(270 40% 20%), hsl(220 50% 25%));
            --gradient-aurora: linear-gradient(90deg, hsl(270 60% 40%), hsl(220 70% 50%), hsl(180 60% 45%), hsl(270 60% 40%));
            --gradient-nebula: linear-gradient(45deg, hsl(45 85% 65%), hsl(270 60% 40%), hsl(220 70% 50%));
            --gradient-glass: linear-gradient(135deg, hsla(240, 30%, 25%, .8), hsla(270, 40%, 20%, .6));
            --shadow-cosmic: 0 8px 32px hsla(270, 60%, 40%, .3);
            --shadow-divine: 0 0 30px hsla(45, 85%, 65%, .4);
            --shadow-ethereal: 0 4px 20px hsla(220, 70%, 50%, .3);
            --transition-cosmic: all .6s cubic-bezier(.4, 0, .2, 1);
            --transition-ethereal: all .4s cubic-bezier(.25, .46, .45, .94);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--gradient-cosmic);
            font-family: 'Cormorant Garamond', serif;
            color: hsl(var(--foreground));
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Cosmic Background Effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, hsla(270, 60%, 40%, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, hsla(220, 70%, 50%, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, hsla(45, 85%, 65%, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Floating Particles */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: hsl(var(--primary-glow));
            border-radius: 50%;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) translateX(100px);
                opacity: 0;
            }
        }

        /* Glass Panel Base */
        .glass-panel {
            background: var(--gradient-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid hsl(var(--glass-border) / .3);
            box-shadow: var(--shadow-cosmic);
            border-radius: var(--radius);
        }

        /* Divine Glow Effect */
        .divine-glow {
            box-shadow: var(--shadow-divine);
            transition: var(--transition-ethereal);
        }

        .divine-glow:hover {
            box-shadow: 0 0 40px hsla(var(--primary-glow) / .6);
            transform: translateY(-2px);
        }

        /* Cosmic Shimmer Animation */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .cosmic-shimmer {
            background: linear-gradient(90deg, transparent, hsla(var(--primary-glow) / .4), transparent);
            background-size: 200% 100%;
            animation: shimmer 3s infinite;
        }

        /* Aurora Pulse Animation */
        @keyframes aurora-pulse {
            0%, 100% { opacity: .6; }
            50% { opacity: 1; }
        }

        .aurora-pulse {
            animation: aurora-pulse 4s ease-in-out infinite;
        }

        /* Layout Structure */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        section {
            margin: 2rem 0;
            padding: 2rem;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 4rem 2rem;
            position: relative;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            background: var(--gradient-nebula);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px hsla(var(--primary-glow) / .5);
        }

        .hero p {
            font-size: 1.25rem;
            color: hsl(var(--muted-foreground));
            max-width: 600px;
            margin: 0 auto;
        }

        /* Chronoscroll Section */
        .chronoscroll-section {
            min-height: 700px;
            position: relative;
            background: linear-gradient(135deg, 
                hsla(240, 20%, 8%, 0.8) 0%,
                hsla(270, 30%, 12%, 0.6) 25%,
                hsla(300, 25%, 10%, 0.7) 50%,
                hsla(240, 20%, 8%, 0.8) 75%,
                hsla(200, 15%, 6%, 0.9) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid hsla(var(--glass-border) / 0.3);
            box-shadow: 
                0 8px 32px hsla(var(--primary-glow) / 0.1),
                inset 0 1px 0 hsla(var(--glass-border) / 0.2);
        }

        .chronoscroll-canvas {
            width: 100%;
            height: 600px;
            border-radius: var(--radius);
            cursor: crosshair;
            background: 
                radial-gradient(ellipse at 20% 20%, hsla(280, 40%, 20%, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, hsla(200, 30%, 15%, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, hsla(300, 25%, 10%, 0.1) 0%, transparent 70%),
                linear-gradient(135deg, 
                    hsla(240, 15%, 5%, 0.9) 0%,
                    hsla(270, 20%, 8%, 0.8) 50%,
                    hsla(240, 15%, 5%, 0.9) 100%);
            position: relative;
            overflow: hidden;
        }

        .chronoscroll-canvas::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(2px 2px at 20px 30px, hsla(var(--primary-glow) / 0.8), transparent),
                radial-gradient(2px 2px at 40px 70px, hsla(var(--primary-glow) / 0.6), transparent),
                radial-gradient(1px 1px at 90px 40px, hsla(var(--primary-glow) / 0.7), transparent),
                radial-gradient(1px 1px at 130px 80px, hsla(var(--primary-glow) / 0.5), transparent),
                radial-gradient(2px 2px at 160px 30px, hsla(var(--primary-glow) / 0.6), transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: starfield 20s linear infinite;
            pointer-events: none;
        }

        @keyframes starfield {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-100px); }
        }

        /* Memory Orb Styles */
        .memory-orb {
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .memory-orb:hover {
            transform: scale(1.2);
            filter: brightness(1.5);
        }

        .memory-orb.clicked {
            animation: cosmic-violation 0.5s ease-in-out infinite;
        }

        @keyframes cosmic-violation {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            25% { filter: hue-rotate(15deg) brightness(1.2) saturate(1.5); }
            50% { filter: hue-rotate(-15deg) brightness(0.8) saturate(0.5); }
            75% { filter: hue-rotate(10deg) brightness(1.1) saturate(1.2); }
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: hsl(var(--card));
            color: hsl(var(--card-foreground));
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            box-shadow: var(--shadow-ethereal);
            border: 1px solid hsl(var(--glass-border) / .3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s ease;
        }

        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip h3 {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: hsl(var(--primary));
        }

        /* Record Panel Modal */
        .record-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--glass-border) / .3);
            border-radius: var(--radius);
            box-shadow: var(--shadow-cosmic);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        .record-panel.show {
            opacity: 1;
            visibility: visible;
        }

        .record-panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid hsl(var(--border));
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .record-panel-content {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .record-metadata {
            background: hsla(var(--glass) / 0.2);
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid hsla(var(--glass-border) / 0.3);
        }

        .record-details {
            background: hsla(var(--glass) / 0.1);
            border-radius: var(--radius);
            padding: 1rem;
        }

        .record-panel-content p {
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }

        .record-metadata p {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .record-metadata strong {
            color: hsl(var(--primary));
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: hsl(var(--muted-foreground));
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: var(--transition-ethereal);
        }

        .close-btn:hover {
            color: hsl(var(--foreground));
            background: hsl(var(--muted) / .5);
        }

        /* Placeholder Sections */
        .placeholder-section {
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: hsl(var(--muted-foreground));
        }

        .placeholder-content h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: hsl(var(--primary));
        }

        .placeholder-content p {
            font-size: 1.125rem;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Filter Controls */
        .filter-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-label {
            font-size: 0.9rem;
            color: hsl(var(--muted-foreground));
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-select {
            padding: 0.75rem 1rem;
            background: hsla(var(--glass) / 0.4);
            border: 1px solid hsla(var(--glass-border) / 0.4);
            border-radius: var(--radius);
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: inherit;
            font-size: 0.9rem;
            min-width: 140px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        .filter-select:hover {
            background: hsla(var(--glass) / 0.6);
            border-color: hsla(var(--glass-border) / 0.6);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px hsla(var(--primary-glow) / 0.2);
        }

        .filter-select:focus {
            outline: none;
            border-color: hsla(var(--primary) / 0.6);
            box-shadow: 0 0 20px hsla(var(--primary-glow) / 0.3);
        }

        .filter-select option {
            background: hsl(var(--popover));
            color: hsl(var(--popover-foreground));
            padding: 0.5rem;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem;
            margin-top: 4rem;
            border-top: 1px solid hsl(var(--border));
            color: hsl(var(--muted-foreground));
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .hero p {
                font-size: 1rem;
            }
            
            .filter-controls {
                justify-content: center;
            }
            
            .record-panel {
                width: 95%;
                margin: 1rem;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid hsl(var(--muted));
            border-radius: 50%;
            border-top-color: hsl(var(--primary));
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mirror of Self Styles */
        .mirror-section {
            min-height: 600px;
            position: relative;
            background: 
                radial-gradient(circle at 30% 70%, hsla(270, 60%, 40%, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, hsla(220, 70%, 50%, 0.1) 0%, transparent 50%);
        }

        .mirror-canvas {
            width: 100%;
            height: 500px;
            border-radius: var(--radius);
            cursor: crosshair;
            background: transparent;
        }

        .mirror-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .seed-input {
            flex: 1;
            min-width: 200px;
            padding: 0.75rem 1rem;
            background: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: 0.5rem;
            font-family: inherit;
            font-size: 1rem;
            transition: var(--transition-ethereal);
        }

        .seed-input:focus {
            outline: none;
            border-color: hsl(var(--accent));
            background: hsl(var(--accent) / .1);
            color: hsl(var(--accent));
        }

        .bind-btn {
            padding: 0.75rem 1.5rem;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 500;
            transition: var(--transition-ethereal);
        }

        .bind-btn:hover {
            background: hsl(var(--primary-glow));
            transform: translateY(-1px);
            box-shadow: var(--shadow-divine);
        }

        .constellation-star {
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .constellation-star:hover {
            transform: scale(1.3);
            filter: brightness(1.8);
        }

        .constellation-star.trace {
            animation: trace-pulse 2s ease-in-out infinite;
        }

        @keyframes trace-pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }

        /* Reflection Panel */
        .reflection-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--glass-border) / .3);
            border-radius: var(--radius);
            box-shadow: var(--shadow-cosmic);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        .reflection-panel.show {
            opacity: 1;
            visibility: visible;
        }

        .reflection-panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid hsl(var(--border));
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reflection-panel-content {
            padding: 1.5rem;
        }

        .star-interpretation {
            margin-bottom: 1rem;
        }

        .star-interpretation h3 {
            color: hsl(var(--primary));
            margin-bottom: 0.5rem;
        }

        .star-traits {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .trait-tag {
            padding: 0.25rem 0.75rem;
            background: hsl(var(--accent) / .2);
            color: hsl(var(--accent));
            border: 1px solid hsl(var(--accent) / .3);
            border-radius: 1rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <!-- Floating Particles -->
    <div class="particles" id="particles"></div>

    <div class="container">
        <!-- Hero Section -->
        <section class="hero">
            <h1>Akashic Records — Nexus of Infinity</h1>
            <p>Access the cosmic database of all events, thoughts, and experiences across time and space</p>
        </section>

        <!-- Chronoscroll Section -->
        <section class="chronoscroll-section glass-panel">
            <h2 style="margin-bottom: 1rem; color: hsl(var(--primary)); font-size: 1.5rem;">Chronoscroll — Timeline of Records</h2>
            
            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-group">
                    <label class="filter-label">Realm:</label>
                    <select class="filter-select" id="realm-filter">
                        <option value="all">All Realms</option>
                        <option value="earth">Earth</option>
                        <option value="astral">Astral</option>
                        <option value="etheric">Etheric</option>
                        <option value="simulation">Simulation</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label class="filter-label">Epoch:</label>
                    <select class="filter-select" id="epoch-filter">
                        <option value="all">All Epochs</option>
                        <option value="ancient">Ancient</option>
                        <option value="modern">Modern</option>
                        <option value="future">Future</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label class="filter-label">Dimension:</label>
                    <select class="filter-select" id="dimension-filter">
                        <option value="all">All Dimensions</option>
                        <option value="1d">1D</option>
                        <option value="2d">2D</option>
                        <option value="3d">3D</option>
                        <option value="4d">4D</option>
                        <option value="5d">5D</option>
                        <option value="6d">6D</option>
                        <option value="7d">7D</option>
                        <option value="8d">8D</option>
                        <option value="9d">9D</option>
                        <option value="10d">10D</option>
                        <option value="11d">11D</option>
                        <option value="12d">12D</option>
                    </select>
                </div>
            </div>

            <!-- Canvas for Memory Orbs -->
            <canvas id="chronoscroll-canvas" class="chronoscroll-canvas"></canvas>
        </section>

        <!-- Mirror of Self Section -->
        <section class="mirror-section glass-panel">
            <h2 style="margin-bottom: 1rem; color: hsl(var(--primary)); font-size: 1.5rem;">Mirror of Self — Constellation Avatar</h2>
            
            <!-- Seed Controls -->
            <div class="mirror-controls">
                <input type="text" id="seed-input" class="seed-input" placeholder="Enter your name or phrase to generate constellation..." />
                <button id="bind-btn" class="bind-btn">Bind</button>
            </div>

            <!-- Constellation Canvas -->
            <canvas id="mos-canvas" class="mirror-canvas"></canvas>
        </section>

        <!-- Voices of the Demiurge Section -->
        <section class="placeholder-section glass-panel">
            <div class="placeholder-content">
                <h2>Voices of the Demiurge</h2>
                <p>Cosmic intelligence dialogue panel with voice switching will be implemented here</p>
            </div>
        </section>

        <!-- Rules of the Realm Section -->
        <section class="placeholder-section glass-panel">
            <div class="placeholder-content">
                <h2>Rules of the Realm Codex</h2>
                <p>Sacred laws and cosmic principles will be displayed in an interactive codex format</p>
            </div>
        </section>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <h3 id="tooltip-title"></h3>
        <p id="tooltip-description"></p>
    </div>

    <!-- Record Panel Modal -->
    <div class="record-panel" id="record-panel">
        <div class="record-panel-header">
            <h2 id="record-title">Memory Record</h2>
            <button class="close-btn" id="close-panel">&times;</button>
        </div>
        <div class="record-panel-content">
            <div id="record-content">
                <div class="record-metadata">
                    <p><strong>Date:</strong> <span id="record-date"></span></p>
                    <p><strong>Realm:</strong> <span id="record-realm"></span></p>
                    <p><strong>Epoch:</strong> <span id="record-epoch"></span></p>
                    <p><strong>Dimension:</strong> <span id="record-dimension"></span></p>
                </div>
                <div class="record-details">
                    <p><strong>Emotion:</strong> <span id="record-emotion"></span></p>
                    <p><strong>Lesson:</strong> <span id="record-lesson"></span></p>
                    <p><strong>Description:</strong> <span id="record-description"></span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Reflection Panel Modal -->
    <div class="reflection-panel" id="reflection-panel">
        <div class="reflection-panel-header">
            <h2 id="reflection-title">Star Reflection</h2>
            <button class="close-btn" id="close-reflection">&times;</button>
        </div>
        <div class="reflection-panel-content">
            <div class="star-interpretation">
                <h3 id="star-name">Constellation Node</h3>
                <div class="star-traits" id="star-traits">
                    <span class="trait-tag">Seeker</span>
                    <span class="trait-tag">Flame</span>
                    <span class="trait-tag">Compassion</span>
                </div>
                <p id="star-interpretation">This star represents a key aspect of your soul's journey...</p>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p>Akashic Records GUI — Foundation Build | Built with cosmic technology</p>
    </footer>

    <script>
        class Chronoscroll {
            constructor() {
                this.canvas = document.getElementById('chronoscroll-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.orbs = [];
                this.tooltip = document.getElementById('tooltip');
                this.recordPanel = document.getElementById('record-panel');
                this.particles = document.getElementById('particles');
                
                this.init();
                this.createParticles();
                this.createMemoryOrbs();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            createParticles() {
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 20 + 's';
                    particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
                    this.particles.appendChild(particle);
                }
            }

            createMemoryOrbs() {
                const orbCount = 80;
                const orbTypes = [
                    { name: 'Memory Orb', color: 'hsl(45, 85%, 65%)', size: 8, glowColor: 'hsl(45, 100%, 80%)' },
                    { name: 'Soul Fragment', color: 'hsl(270, 60%, 40%)', size: 6, glowColor: 'hsl(270, 80%, 60%)' },
                    { name: 'Time Echo', color: 'hsl(220, 70%, 50%)', size: 10, glowColor: 'hsl(220, 90%, 70%)' },
                    { name: 'Cosmic Event', color: 'hsl(300, 70%, 55%)', size: 9, glowColor: 'hsl(300, 90%, 75%)' },
                    { name: 'Divine Moment', color: 'hsl(45, 100%, 75%)', size: 5, glowColor: 'hsl(45, 100%, 90%)' }
                ];

                for (let i = 0; i < orbCount; i++) {
                    const orbType = orbTypes[Math.floor(Math.random() * orbTypes.length)];
                    const orb = {
                        x: Math.random() * (this.canvas.width - 20) + 10,
                        y: Math.random() * (this.canvas.height - 20) + 10,
                        size: orbType.size,
                        color: orbType.color,
                        glowColor: orbType.glowColor,
                        type: orbType.name,
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.02 + Math.random() * 0.03,
                        glowIntensity: 0.5 + Math.random() * 0.5,
                        sparkPhase: Math.random() * Math.PI * 2,
                        sparkSpeed: 0.05 + Math.random() * 0.05,
                        title: this.generateOrbTitle(orbType.name),
                        description: this.generateOrbDescription(orbType.name),
                        date: this.generateRandomDate(),
                        emotion: this.generateRandomEmotion(),
                        lesson: this.generateRandomLesson(),
                        realm: this.generateRandomRealm(),
                        epoch: this.generateRandomEpoch(),
                        dimension: this.generateRandomDimension()
                    };
                    this.orbs.push(orb);
                }
            }

            generateOrbTitle(type) {
                const titles = {
                    'Memory Orb': ['Ancient Wisdom', 'Forgotten Dreams', 'Sacred Moment', 'Eternal Memory', 'Cosmic Remembrance'],
                    'Soul Fragment': ['Soul Echo', 'Spiritual Essence', 'Divine Spark', 'Cosmic Fragment', 'Ethereal Essence'],
                    'Time Echo': ['Temporal Resonance', 'Time Ripple', 'Chronological Echo', 'Moment Reverb', 'Quantum Echo'],
                    'Cosmic Event': ['Galactic Birth', 'Stellar Collision', 'Universal Shift', 'Dimensional Rift', 'Cosmic Awakening'],
                    'Divine Moment': ['Divine Light', 'Sacred Flame', 'Heavenly Glow', 'Celestial Fire', 'Transcendent Spark']
                };
                return titles[type][Math.floor(Math.random() * titles[type].length)];
            }

            generateOrbDescription(type) {
                const descriptions = {
                    'Memory Orb': 'A fragment of consciousness containing memories from across the cosmic timeline',
                    'Soul Fragment': 'A piece of spiritual essence that carries the essence of a soul\'s journey',
                    'Time Echo': 'A resonance of events that ripples through the fabric of spacetime',
                    'Cosmic Event': 'A momentous occurrence that shapes the destiny of galaxies and dimensions',
                    'Divine Moment': 'A fragment of divine light that illuminates the path to enlightenment'
                };
                return descriptions[type];
            }

            generateRandomDate() {
                const years = ['Ancient Era', 'Medieval Times', 'Renaissance', 'Modern Age', 'Future Epoch'];
                return years[Math.floor(Math.random() * years.length)];
            }

            generateRandomEmotion() {
                const emotions = ['Joy', 'Sorrow', 'Love', 'Fear', 'Hope', 'Peace', 'Wonder', 'Longing'];
                return emotions[Math.floor(Math.random() * emotions.length)];
            }

            generateRandomLesson() {
                const lessons = [
                    'All experiences serve the soul\'s growth',
                    'Love is the fundamental force of creation',
                    'Time is an illusion of the material realm',
                    'Every choice creates ripples across dimensions',
                    'Wisdom comes through embracing both light and shadow'
                ];
                return lessons[Math.floor(Math.random() * lessons.length)];
            }

            generateRandomRealm() {
                const realms = ['Earth', 'Astral', 'Etheric', 'Simulation'];
                return realms[Math.floor(Math.random() * realms.length)];
            }

            generateRandomEpoch() {
                const epochs = ['Ancient', 'Modern', 'Future'];
                return epochs[Math.floor(Math.random() * epochs.length)];
            }

            generateRandomDimension() {
                const dimensions = ['1D', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', '10D', '11D', '12D'];
                return dimensions[Math.floor(Math.random() * dimensions.length)];
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                document.getElementById('close-panel').addEventListener('click', () => this.closeRecordPanel());
                document.getElementById('record-panel').addEventListener('click', (e) => {
                    if (e.target === this.recordPanel) this.closeRecordPanel();
                });

                // Filter dropdowns
                document.getElementById('realm-filter').addEventListener('change', (e) => this.handleFilterChange(e));
                document.getElementById('epoch-filter').addEventListener('change', (e) => this.handleFilterChange(e));
                document.getElementById('dimension-filter').addEventListener('change', (e) => this.handleFilterChange(e));
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let hoveredOrb = null;
                for (const orb of this.orbs) {
                    const distance = Math.sqrt((x - orb.x) ** 2 + (y - orb.y) ** 2);
                    if (distance < orb.size + 10) {
                        hoveredOrb = orb;
                        break;
                    }
                }

                if (hoveredOrb) {
                    this.showTooltip(e.clientX, e.clientY, hoveredOrb);
                } else {
                    this.hideTooltip();
                }
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                for (const orb of this.orbs) {
                    const distance = Math.sqrt((x - orb.x) ** 2 + (y - orb.y) ** 2);
                    if (distance < orb.size + 10) {
                        this.openRecordPanel(orb);
                        orb.clicked = true;
                        setTimeout(() => {
                            orb.clicked = false;
                            // Respawn orb in new location
                            orb.x = Math.random() * (this.canvas.width - 20) + 10;
                            orb.y = Math.random() * (this.canvas.height - 20) + 10;
                        }, 1000);
                        break;
                    }
                }
            }

            showTooltip(x, y, orb) {
                this.tooltip.querySelector('#tooltip-title').textContent = orb.title;
                this.tooltip.querySelector('#tooltip-description').textContent = orb.description;
                
                // Position tooltip to avoid screen edges
                const tooltipRect = this.tooltip.getBoundingClientRect();
                let tooltipX = x + 10;
                let tooltipY = y - 10;

                if (tooltipX + tooltipRect.width > window.innerWidth) {
                    tooltipX = x - tooltipRect.width - 10;
                }
                if (tooltipY < 0) {
                    tooltipY = y + 20;
                }

                this.tooltip.style.left = tooltipX + 'px';
                this.tooltip.style.top = tooltipY + 'px';
                this.tooltip.classList.add('show');
            }

            hideTooltip() {
                this.tooltip.classList.remove('show');
            }

            openRecordPanel(orb) {
                document.getElementById('record-title').textContent = orb.title;
                document.getElementById('record-date').textContent = orb.date;
                document.getElementById('record-emotion').textContent = orb.emotion;
                document.getElementById('record-lesson').textContent = orb.lesson;
                document.getElementById('record-description').textContent = orb.description;
                document.getElementById('record-realm').textContent = orb.realm;
                document.getElementById('record-epoch').textContent = orb.epoch;
                document.getElementById('record-dimension').textContent = orb.dimension;
                
                this.recordPanel.classList.add('show');
            }

            closeRecordPanel() {
                this.recordPanel.classList.remove('show');
            }

            handleFilterChange(e) {
                const filterType = e.target.id.replace('-filter', '');
                const filterValue = e.target.value;
                
                // Add visual effect to show filter is active
                this.orbs.forEach(orb => {
                    orb.filterPulse = true;
                    setTimeout(() => orb.filterPulse = false, 1000);
                });
                
                // In a full implementation, this would filter the orbs based on their properties
                // For now, we'll just add a visual effect
                console.log(`Filter changed: ${filterType} = ${filterValue}`);
            }

            drawOrb(orb) {
                const ctx = this.ctx;
                
                // Update animation phases
                orb.pulsePhase += orb.pulseSpeed;
                orb.sparkPhase += orb.sparkSpeed;
                
                // Outer aura glow (largest)
                const auraGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.size * 4);
                auraGradient.addColorStop(0, orb.glowColor + '30');
                auraGradient.addColorStop(0.3, orb.glowColor + '20');
                auraGradient.addColorStop(0.7, orb.glowColor + '10');
                auraGradient.addColorStop(1, orb.glowColor + '00');
                
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size * 4, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow (medium)
                const glowGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.size * 2.5);
                glowGradient.addColorStop(0, orb.color + '60');
                glowGradient.addColorStop(0.4, orb.color + '40');
                glowGradient.addColorStop(0.8, orb.color + '20');
                glowGradient.addColorStop(1, orb.color + '00');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Main orb body
                const bodyGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.size);
                bodyGradient.addColorStop(0, orb.color + 'FF');
                bodyGradient.addColorStop(0.6, orb.color + 'CC');
                bodyGradient.addColorStop(0.9, orb.color + '88');
                bodyGradient.addColorStop(1, orb.color + '44');
                
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2);
                ctx.fill();

                // Inner spark/core
                const sparkScale = 1 + Math.sin(orb.sparkPhase) * 0.3;
                const sparkSize = orb.size * 0.4 * sparkScale;
                
                const sparkGradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, sparkSize);
                sparkGradient.addColorStop(0, orb.glowColor + 'FF');
                sparkGradient.addColorStop(0.5, orb.glowColor + 'CC');
                sparkGradient.addColorStop(1, orb.glowColor + '66');
                
                ctx.fillStyle = sparkGradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, sparkSize, 0, Math.PI * 2);
                ctx.fill();

                // Pulsing effect
                const pulseScale = 1 + Math.sin(orb.pulsePhase) * 0.15;
                ctx.save();
                ctx.translate(orb.x, orb.y);
                ctx.scale(pulseScale, pulseScale);
                ctx.translate(-orb.x, -orb.y);
                
                // Inner core highlight
                ctx.fillStyle = orb.glowColor + 'AA';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();

                // Filter pulse effect
                if (orb.filterPulse) {
                    ctx.strokeStyle = orb.glowColor;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = orb.glowColor;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, orb.size * 2.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw orbs
                this.orbs.forEach(orb => this.drawOrb(orb));
                
                requestAnimationFrame(() => this.animate());
            }
        }

        class MirrorOfSelf {
            constructor() {
                this.canvas = document.getElementById('mos-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.stars = [];
                this.tooltip = document.getElementById('tooltip');
                this.reflectionPanel = document.getElementById('reflection-panel');
                this.seedInput = document.getElementById('seed-input');
                this.bindBtn = document.getElementById('bind-btn');
                this.currentSeed = 'default';
                
                this.init();
                this.setupEventListeners();
                this.generateConstellation();
                this.animate();
            }

            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            // Seeded random number generator
            seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            generateConstellation() {
                this.stars = [];
                const starCount = 45;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Generate stars in radial pattern
                for (let i = 0; i < starCount; i++) {
                    const angle = (i / starCount) * Math.PI * 2;
                    const distance = 50 + (this.seededRandom(this.currentSeed + i) * 150);
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    const star = {
                        x: x,
                        y: y,
                        size: 3 + this.seededRandom(this.currentSeed + i + 100) * 4,
                        pulsePhase: this.seededRandom(this.currentSeed + i + 200) * Math.PI * 2,
                        pulseSpeed: 0.01 + this.seededRandom(this.currentSeed + i + 300) * 0.02,
                        archetype: this.generateArchetype(this.currentSeed + i + 400),
                        element: this.generateElement(this.currentSeed + i + 500),
                        virtue: this.generateVirtue(this.currentSeed + i + 600),
                        color: this.generateStarColor(this.currentSeed + i + 700),
                        glowColor: this.generateGlowColor(this.currentSeed + i + 800),
                        isTrace: false
                    };
                    this.stars.push(star);
                }
            }

            generateArchetype(seed) {
                const archetypes = ['Seeker', 'Guardian', 'Sage', 'Warrior', 'Healer', 'Creator', 'Mystic', 'Wanderer'];
                return archetypes[Math.floor(this.seededRandom(seed) * archetypes.length)];
            }

            generateElement(seed) {
                const elements = ['Flame', 'Water', 'Earth', 'Air', 'Spirit', 'Void', 'Light', 'Shadow'];
                return elements[Math.floor(this.seededRandom(seed) * elements.length)];
            }

            generateVirtue(seed) {
                const virtues = ['Compassion', 'Wisdom', 'Courage', 'Patience', 'Love', 'Truth', 'Harmony', 'Grace'];
                return virtues[Math.floor(this.seededRandom(seed) * virtues.length)];
            }

            generateStarColor(seed) {
                const colors = [
                    'hsl(45, 85%, 65%)',   // Golden
                    'hsl(270, 60%, 40%)',   // Purple
                    'hsl(220, 70%, 50%)',   // Blue
                    'hsl(300, 70%, 55%)',   // Magenta
                    'hsl(180, 60%, 45%)',   // Cyan
                    'hsl(45, 100%, 75%)'    // Bright Gold
                ];
                return colors[Math.floor(this.seededRandom(seed) * colors.length)];
            }

            generateGlowColor(seed) {
                const glowColors = [
                    'hsl(45, 100%, 80%)',   // Bright Golden
                    'hsl(270, 80%, 60%)',   // Bright Purple
                    'hsl(220, 90%, 70%)',   // Bright Blue
                    'hsl(300, 90%, 75%)',   // Bright Magenta
                    'hsl(180, 80%, 65%)',   // Bright Cyan
                    'hsl(45, 100%, 90%)'    // Brightest Gold
                ];
                return glowColors[Math.floor(this.seededRandom(seed) * glowColors.length)];
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.bindBtn.addEventListener('click', () => this.bindSeed());
                this.seedInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.bindSeed();
                });
                
                document.getElementById('close-reflection').addEventListener('click', () => this.closeReflectionPanel());
                this.reflectionPanel.addEventListener('click', (e) => {
                    if (e.target === this.reflectionPanel) this.closeReflectionPanel();
                });
            }

            bindSeed() {
                const seed = this.seedInput.value.trim() || 'default';
                this.currentSeed = seed;
                this.generateConstellation();
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let hoveredStar = null;
                for (const star of this.stars) {
                    const distance = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                    if (distance < star.size + 8) {
                        hoveredStar = star;
                        break;
                    }
                }

                if (hoveredStar) {
                    this.showTooltip(e.clientX, e.clientY, hoveredStar);
                } else {
                    this.hideTooltip();
                }
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                for (const star of this.stars) {
                    const distance = Math.sqrt((x - star.x) ** 2 + (y - star.y) ** 2);
                    if (distance < star.size + 8) {
                        this.openReflectionPanel(star);
                        break;
                    }
                }
            }

            showTooltip(x, y, star) {
                this.tooltip.querySelector('#tooltip-title').textContent = `${star.archetype} • ${star.element} • ${star.virtue}`;
                this.tooltip.querySelector('#tooltip-description').textContent = `A constellation node representing your ${star.archetype.toLowerCase()} nature`;
                
                // Position tooltip to avoid screen edges
                const tooltipRect = this.tooltip.getBoundingClientRect();
                let tooltipX = x + 10;
                let tooltipY = y - 10;

                if (tooltipX + tooltipRect.width > window.innerWidth) {
                    tooltipX = x - tooltipRect.width - 10;
                }
                if (tooltipY < 0) {
                    tooltipY = y + 20;
                }

                this.tooltip.style.left = tooltipX + 'px';
                this.tooltip.style.top = tooltipY + 'px';
                this.tooltip.classList.add('show');
            }

            hideTooltip() {
                this.tooltip.classList.remove('show');
            }

            openReflectionPanel(star) {
                document.getElementById('reflection-title').textContent = `${star.archetype} Reflection`;
                document.getElementById('star-name').textContent = `${star.archetype} • ${star.element} • ${star.virtue}`;
                
                // Update trait tags
                const traitsContainer = document.getElementById('star-traits');
                traitsContainer.innerHTML = `
                    <span class="trait-tag">${star.archetype}</span>
                    <span class="trait-tag">${star.element}</span>
                    <span class="trait-tag">${star.virtue}</span>
                `;
                
                // Update interpretation
                const interpretation = this.generateInterpretation(star);
                document.getElementById('star-interpretation-text').textContent = interpretation;
                
                this.reflectionPanel.classList.add('show');
            }

            generateInterpretation(star) {
                const interpretations = {
                    'Seeker': `The ${star.archetype} archetype represents your eternal quest for truth and understanding. Your ${star.element.toLowerCase()} nature brings ${star.virtue.toLowerCase()} to your journey.`,
                    'Guardian': `The ${star.archetype} archetype embodies your protective instincts and nurturing spirit. Your ${star.element.toLowerCase()} essence channels ${star.virtue.toLowerCase()} in service to others.`,
                    'Sage': `The ${star.archetype} archetype reflects your wisdom and knowledge-seeking nature. Your ${star.element.toLowerCase()} energy manifests as ${star.virtue.toLowerCase()} in your teachings.`,
                    'Warrior': `The ${star.archetype} archetype represents your courage and determination. Your ${star.element.toLowerCase()} spirit embodies ${star.virtue.toLowerCase()} in your battles.`,
                    'Healer': `The ${star.archetype} archetype signifies your gift for restoration and compassion. Your ${star.element.toLowerCase()} nature brings ${star.virtue.toLowerCase()} to your healing work.`,
                    'Creator': `The ${star.archetype} archetype embodies your creative and innovative spirit. Your ${star.element.toLowerCase()} essence channels ${star.virtue.toLowerCase()} into your creations.`,
                    'Mystic': `The ${star.archetype} archetype represents your connection to the divine and unseen realms. Your ${star.element.toLowerCase()} nature manifests ${star.virtue.toLowerCase()} in your spiritual practice.`,
                    'Wanderer': `The ${star.archetype} archetype reflects your free spirit and love of exploration. Your ${star.element.toLowerCase()} energy brings ${star.virtue.toLowerCase()} to your adventures.`
                };
                return interpretations[star.archetype] || `The ${star.archetype} archetype represents a unique aspect of your soul's journey.`;
            }

            closeReflectionPanel() {
                this.reflectionPanel.classList.remove('show');
            }

            // Global function for adding traces from other components
            addTrace(tag) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Create a new star near the center
                const traceStar = {
                    x: centerX + (Math.random() - 0.5) * 40,
                    y: centerY + (Math.random() - 0.5) * 40,
                    size: 4 + Math.random() * 2,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.02 + Math.random() * 0.03,
                    archetype: 'Trace',
                    element: 'Ether',
                    virtue: 'Connection',
                    color: 'hsl(45, 100%, 75%)',
                    glowColor: 'hsl(45, 100%, 90%)',
                    isTrace: true,
                    tag: tag
                };
                
                this.stars.push(traceStar);
                
                // Remove oldest trace if we have too many
                if (this.stars.filter(s => s.isTrace).length > 10) {
                    const traceIndex = this.stars.findIndex(s => s.isTrace);
                    if (traceIndex !== -1) {
                        this.stars.splice(traceIndex, 1);
                    }
                }
            }

            drawStar(star) {
                const ctx = this.ctx;
                
                // Update pulse phase
                star.pulsePhase += star.pulseSpeed;
                const pulseScale = 1 + Math.sin(star.pulsePhase) * 0.3;
                
                // Outer glow
                const glowGradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.size * 3);
                glowGradient.addColorStop(0, star.glowColor + '40');
                glowGradient.addColorStop(0.5, star.glowColor + '20');
                glowGradient.addColorStop(1, star.glowColor + '00');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
                ctx.fill();

                // Main star body
                const bodyGradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.size);
                bodyGradient.addColorStop(0, star.color + 'FF');
                bodyGradient.addColorStop(0.7, star.color + 'CC');
                bodyGradient.addColorStop(1, star.color + '88');
                
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // Inner spark
                ctx.fillStyle = star.glowColor + 'FF';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * 0.3 * pulseScale, 0, Math.PI * 2);
                ctx.fill();
            }

            drawConnections() {
                const ctx = this.ctx;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Draw connections to nearest stars
                for (let i = 0; i < this.stars.length; i++) {
                    const star = this.stars[i];
                    let nearestDistance = Infinity;
                    let nearestStar = null;
                    
                    // Find nearest star
                    for (let j = 0; j < this.stars.length; j++) {
                        if (i === j) continue;
                        const otherStar = this.stars[j];
                        const distance = Math.sqrt((star.x - otherStar.x) ** 2 + (star.y - otherStar.y) ** 2);
                        if (distance < nearestDistance && distance < 100) {
                            nearestDistance = distance;
                            nearestStar = otherStar;
                        }
                    }
                    
                    // Draw connection line
                    if (nearestStar) {
                        ctx.strokeStyle = star.color + '30';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(star.x, star.y);
                        ctx.lineTo(nearestStar.x, nearestStar.y);
                        ctx.stroke();
                    }
                }
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw connections first
                this.drawConnections();
                
                // Draw stars
                this.stars.forEach(star => this.drawStar(star));
                
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize the Chronoscroll when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new Chronoscroll();
            window.MirrorOfSelf = new MirrorOfSelf();
        });
    </script>
</body>
</html>